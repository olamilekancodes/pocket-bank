**Pocket Bank is a premium digital banking dashboard built using React and TypeScript. The application is styled exclusively with pure CSS Modules to ensure a high-performance, zero-dependency UI that remains maintainable as the project grows. The development follows a strict feature-based architectural structure combined with a smart and dumb component approach. This means that logic and presentation are clearly separated: smart components handle state management and business logic, while dumb components are focused solely on rendering the UI based on the props they receive. The application achieves high scalability by organizing the codebase into domain-specific features rather than generic folders.**

1. **Security: In a real fintech application, how would you handle the "Auth Token" for the API? Where would you store it, and where would you never store it?**

In a real-world fintech application, handling authorization tokens requires extreme caution to prevent theft via Cross-Site Scripting (XSS) or Cross-Site Request Forgery (CSRF). In such an environment, I would handle the Auth Token using HttpOnly cookies with the Secure and SameSite flags enabled. This ensures that the token is never accessible to JavaScript, effectively neutralizing common XSS attacks. I would never store sensitive tokens in LocalStorage or SessionStorage, as these are easily accessible to malicious scripts. For enhanced security, a production-ready app would utilize a short-lived access token stored in memory and a long-lived refresh token stored in an HttpOnly cookie to maintain user sessions without exposing sensitive data.

2. **Edge Cases: How did you handle floating-point math issues? (e.g., 0.1 + 0.2 !== 0.3 in JS). How would you ensure the balance is accurate in a production app?**

Handling money in JavaScript presents significant challenges due to the way the language handles floating-point math. Simple operations like 0.1 plus 0.2 do not equal 0.3 in standard JavaScript, which can lead to catastrophic rounding errors in a bank ledger. In a production app, I would ensure accuracy by never performing calculations using floats. Instead, all monetary values would be handled as integers in the smallest possible unit, such as kobo. For complex financial calculations, I would implement libraries like Big.js or Decimal.js to handle arbitrary-precision arithmetic, ensuring that the balance shown to the user is always accurate down to the last decimal point.

3. **Architecture: Explain your folder structure. Why did you separate the types/interfaces from the components?**

The folder structure of this project is built around the concept of self-contained features. Each feature contains its own components, logic and state, which prevents the "spaghetti code" common in large-scale React apps. I made the deliberate choice to separate types and interfaces into their own dedicated files within these feature folders. This separation is vital for maintaining a clean dependency graph. By isolating interfaces, I import types into multiple hooks, contexts and components without creating circular dependencies that would break the build process. This approach also serves as a form of living documentation, allowing any developer to understand the data structures of a feature before diving into the implementation details.

4. **Design Handoff: If a designer gave you a UI with no specific font sizes, what logical scale would you use to maintain consistency?**

   When a designer provides a UI without explicit font sizes or spacing rules, I implement a modular scale based on a consistent base unit, typically an 8px grid system. This ensures that all elements in the app are proportional and aesthetically pleasing. For typography, I utilize a logical scale such as the "Major Third" (1.250 ratio), where each font size is a direct multiple of the base 16px size. This creates a clear visual hierarchy between headings, subtext and body copy. By using CSS variables for these scales, I ensure that the entire design system can be adjusted globally by changing a few central values, maintaining harmony throughout the user experience.
